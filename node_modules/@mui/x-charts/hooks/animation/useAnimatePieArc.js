"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimatePieArc = useAnimatePieArc;
var _d3Shape = require("@mui/x-charts-vendor/d3-shape");
var _useForkRef = _interopRequireDefault(require("@mui/utils/useForkRef"));
var _d3Interpolate = require("@mui/x-charts-vendor/d3-interpolate");
var _useAnimate = require("../../internals/animation/useAnimate");
function pieArcPropsInterpolator(from, to) {
  const interpolateStartAngle = (0, _d3Interpolate.interpolateNumber)(from.startAngle, to.startAngle);
  const interpolateEndAngle = (0, _d3Interpolate.interpolateNumber)(from.endAngle, to.endAngle);
  const interpolateInnerRadius = (0, _d3Interpolate.interpolateNumber)(from.innerRadius, to.innerRadius);
  const interpolateOuterRadius = (0, _d3Interpolate.interpolateNumber)(from.outerRadius, to.outerRadius);
  const interpolatePaddingAngle = (0, _d3Interpolate.interpolateNumber)(from.paddingAngle, to.paddingAngle);
  const interpolateCornerRadius = (0, _d3Interpolate.interpolateNumber)(from.cornerRadius, to.cornerRadius);
  return t => {
    return {
      startAngle: interpolateStartAngle(t),
      endAngle: interpolateEndAngle(t),
      innerRadius: interpolateInnerRadius(t),
      outerRadius: interpolateOuterRadius(t),
      paddingAngle: interpolatePaddingAngle(t),
      cornerRadius: interpolateCornerRadius(t)
    };
  };
}

/** Animates a slice of a pie chart by increasing the start and end angles from the middle angle to their final values.
 * The props object also accepts a `ref` which will be merged with the ref returned from this hook. This means you can
 * pass the ref returned by this hook to the `path` element and the `ref` provided as argument will also be called. */
function useAnimatePieArc(props) {
  const initialProps = {
    startAngle: (props.startAngle + props.endAngle) / 2,
    endAngle: (props.startAngle + props.endAngle) / 2,
    innerRadius: props.innerRadius,
    outerRadius: props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  };
  const ref = (0, _useAnimate.useAnimate)({
    startAngle: props.startAngle,
    endAngle: props.endAngle,
    innerRadius: props.innerRadius,
    outerRadius: props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  }, {
    createInterpolator: pieArcPropsInterpolator,
    applyProps(element, animatedProps) {
      element.setAttribute('d', (0, _d3Shape.arc)().cornerRadius(animatedProps.cornerRadius)({
        padAngle: animatedProps.paddingAngle,
        innerRadius: animatedProps.innerRadius,
        outerRadius: animatedProps.outerRadius,
        startAngle: animatedProps.startAngle,
        endAngle: animatedProps.endAngle
      }).toString());
      element.setAttribute('visibility', animatedProps.startAngle === animatedProps.endAngle ? 'hidden' : 'visible');
    },
    initialProps,
    skip: props.skipAnimation
  });
  const usedProps = props.skipAnimation ? props : initialProps;
  return {
    ref: (0, _useForkRef.default)(ref, props.ref),
    d: (0, _d3Shape.arc)().cornerRadius(usedProps.cornerRadius)({
      padAngle: usedProps.paddingAngle,
      innerRadius: usedProps.innerRadius,
      outerRadius: usedProps.outerRadius,
      startAngle: usedProps.startAngle,
      endAngle: usedProps.endAngle
    }),
    visibility: usedProps.startAngle === usedProps.endAngle ? 'hidden' : 'visible'
  };
}